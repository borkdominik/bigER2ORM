/*
 * generated by Xtext 2.28.0
 */
package org.big.orm.generator.sqlalchemy

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.naming.DefaultDeclarativeQualifiedNameProvider
import org.big.orm.ormModel.Embeddable
import org.big.orm.ormModel.DataAttribute
import org.big.orm.ormModel.EmbeddedAttribute
import org.big.orm.ormModel.OrmModel
import com.google.common.base.CaseFormat
import org.big.orm.ormModel.Attribute
import org.big.orm.ormModel.InheritableElement
import java.util.TreeSet
import org.big.orm.ormModel.DataType
import java.util.HashMap
import java.util.Map
import java.util.ArrayList
import org.big.orm.ormModel.Relationship
import org.big.orm.ormModel.Entity
import org.big.orm.ormModel.RelationshipType
import org.big.orm.ormModel.MappedClass
import org.big.orm.ormModel.InheritanceOption
import org.big.orm.ormModel.InheritanceStrategy
import org.big.orm.ormModel.AttributeType
import java.util.List
import java.util.stream.Stream
import java.util.stream.Collectors

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SqlAlchemyOrmModelGenerator extends AbstractGenerator {
	
	extension IQualifiedNameProvider = new DefaultDeclarativeQualifiedNameProvider();

	var Resource resource
	

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		System.err.println("Python generator called!");
		this.resource = resource
		
		var modelName = resource.allContents.toIterable.filter(OrmModel).head.name;
		
		// Adapt Concrete Classes due to bug in 
		
		// Generate Embeddables
        for (e : resource.allContents.toIterable.filter(Embeddable)) {
        	System.err.println("Embeddable to generate: " + e.name + " as " + e.fullyQualifiedName.toString("/") + ".py");
        	fsa.generateFile(
            	modelName + "/entity/" + CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, e.name) + ".py",
            	e.compile);
        }
        
        // Generate Inheritables
        for (e : resource.allContents.toIterable.filter(InheritableElement)) {
        	System.err.println("Embeddable to generate: " + e.name + " as " + e.fullyQualifiedName.toString("/") + ".py");
        	fsa.generateFile(
            	modelName + "/entity/" + CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, e.name) + ".py",
            	e.compile);
        }
	}
	
	private def compile(InheritableElement e) 
	'''
	«FOR i : e.generateImports»
	«i»
	«ENDFOR»
	
	
	«IF (e instanceof MappedClass)»@declarative_mixin«ENDIF»
	class «e.name»«e.compileInheritanceDefinition»:
		«IF (e instanceof Entity) && (!((e as Entity).inheritanceStrategy === InheritanceStrategy.SINGLE_TABLE) || (e as Entity).rootElement === e)»
		__tablename__ = '«CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, e.name)»'
		
		«ENDIF»
		«FOR a : e.attributes.filter(DataAttribute)»
		«a.compileToSqlAlchemyAttribute»
		«ENDFOR»
	    
		«FOR a : e.attributes.filter(EmbeddedAttribute)»
		«a.compileToSqlAlchemyAttribute»
		«ENDFOR»
		
		«IF (e instanceof Entity)»
		«IF (e.inheritanceStrategy === InheritanceStrategy.SINGLE_TABLE)»
		«IF (e.rootElement === e) »
		«IF (!resource.allContents.toIterable.filter(Entity).filter[elem | elem.extends === e].empty)»
		dtype: Mapped[str] = mapped_column(String(31), nullable=False)
		
		__mapper_args__ = {
			"polymorphic_identity": "«CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, e.name)»",
		 	"polymorphic_on": dtype,
		}
		«ENDIF»
		«ELSE»
		__mapper_args__ = {
			"polymorphic_identity": "«CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, e.name)»"
		}
		«ENDIF»
		«ELSEIF (e.inheritanceStrategy === InheritanceStrategy.JOINED_TABLE)»
		«IF (e.rootElement === e)»
		«ELSE»
		__mapper_args__ = {
			"polymorphic_identity": "«CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, e.name)»",
			"inherit_condition": (id == «e.extends.name».id)
		}
		«ENDIF»
		«ELSEIF (e.inheritanceStrategy === InheritanceStrategy.TABLE_PER_CLASS)»
		«IF (e.extends !== null)»
		# TODO: Currently inheriting all attributes, as inheritance is buggy with ConcreteClasses
		«FOR a : e.extends.combineInheritedAttributes»
		«a»
		«ENDFOR»
		
		«IF (e.rootElement === e)»
		__mapper_args__ = {"polymorphic_identity": "«CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, e.name)»"}
		«ELSE»
		__mapper_args__ = {"polymorphic_identity": "«CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, e.name)»", "concrete": True}
		«ENDIF»
		«ENDIF»
		«ENDIF»
		«ENDIF»
	'''
	
	private def compile(Embeddable e) 
	'''
	from dataclasses import dataclass
	
	
	@dataclass
	class «e.name»(object):
		«FOR attribute : e.attributes»
		«attribute.compileToDataclassAttribute»
		«ENDFOR»
	
	'''
	
	private def compileToSqlAlchemyAttribute(DataAttribute a)
	'''
	«CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, a.name)»: Mapped[«a.typeString»] = mapped_column(«a.mappedTypeString»«a.additionalAttributeTypeProperties»)
	'''
	
	private def compileToSqlAlchemyAttribute(EmbeddedAttribute a)
	'''
	«IF a.type === AttributeType.ID»
	«FOR attribute : a.embeddedType.attributes»
	«CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, attribute.name)»: Mapped[«(attribute as DataAttribute).typeString»] = «(attribute as DataAttribute).embeddedDataAttributeToMappedColumn(true)»
	«ENDFOR»
	«CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, a.name)»: Mapped[«a.embeddedType.name»] = composite(«String.join(", ", a.embeddedType.attributes.filter(DataAttribute).map[value | "\"" + CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, value.name) + "\""])»)
	«ELSE»
	«CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, a.name)»: Mapped[«a.embeddedType.name»] = composite(«a.embeddedType.compileCombinedCompositeColumns»)
	«ENDIF»
	'''
	
	private def compileCombinedCompositeColumns(Embeddable e)
	'''«e.attributes.filter(DataAttribute).map[value | value.embeddedDataAttributeToMappedColumn(false)].join(",\n		")»'''
	
	
	private def List<CharSequence> combineInheritedAttributes(InheritableElement i)
	{
		val attributes = new ArrayList<CharSequence>()
		if (i.extends !== null) {
			attributes.addAll(i.extends.combineInheritedAttributes)
			attributes.add('''
			''')
		}
		
		for (attribute : i.attributes.filter(DataAttribute)) {
			attributes.add(attribute.compileToSqlAlchemyAttribute)
		}
		
		for (attribute : i.attributes.filter(EmbeddedAttribute)) {
			attributes.add(attribute.compileToSqlAlchemyAttribute)
		}
		return attributes
	}
	
	private def embeddedDataAttributeToMappedColumn(DataAttribute a, Boolean id)
	'''mapped_column("«CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, a.name)»", «a.mappedTypeString»«IF id», primary_key=True«ELSE», nullable=True«ENDIF»)'''
	
	private def compileInheritanceDefinition(InheritableElement a) {
		if (a instanceof Entity) {
			var InheritanceStrategy strategy = a.inheritanceStrategy
			if (a === a.rootElement) {
				if (strategy === InheritanceStrategy.TABLE_PER_CLASS) {
					return "(ConcreteBase, Base)"
				} else {
					if (a.extends !== null && a.extends instanceof MappedClass) {
						return "(Base, " + a.extends.name + ")"
					} else {
						return "(Base)"
					}
				}
			} else {
				return "(" + a.extends.name + ")"
			}
		} else {
			return ""
		}
	}
	
	private def InheritanceStrategy getInheritanceStrategy(Entity e) {
		if (e.extends !== null && e.extends instanceof Entity) {
			return (e.extends as Entity).inheritanceStrategy
		}
		if (!(e.options.filter(InheritanceOption).empty)){
			return e.options.filter(InheritanceOption).get(0).option
		} else {
			return InheritanceStrategy.SINGLE_TABLE
		}
	}
	
	private def Entity getRootElement(Entity e) {
		if (e.extends !== null && e.extends instanceof Entity) {
			return (e.extends as Entity).rootElement
		}
		return e
	}
	
	private def compileToDataclassAttribute(Attribute a)
	'''
	«CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, a.name)»: «a.typeString»
	'''
	
	def String getMappedTypeString(DataAttribute a){
		return switch (a.datatype){
				case BOOLEAN: "Boolean"
				case INT: "Integer"
				case STRING: "String(255)"
				case UUID: "UUID(as_uuid=True)"
			}
	}
	
	def String getAdditionalAttributeTypeProperties(DataAttribute a){
		return switch (a.type){
				case NONE: ", nullable=True"
				case ID: ", primary_key=True, default=uuid.uuid4()"
				case REQUIRED: ""
			}
	}
	
	def String getTypeString(Attribute a){
		if (a instanceof EmbeddedAttribute){
			return a.embeddedType.name
		} else if (a instanceof DataAttribute) {
			return switch (a.datatype){
				case BOOLEAN: "bool"
				case INT: "int"
				case STRING: "str"
				case UUID: "uuid.UUID"
			}
		}
	}
	
	private def List<String> generateImports(InheritableElement e) {
		val imports = new TreeSet<String>();
		val importFroms = new HashMap<String, TreeSet<String>>();
		val finalFromImports = new TreeSet<String>();
		
		// PREPARE RELATIONS
		
		val elementSourceRelations = new ArrayList<Relationship>();
		val elementTargetRelations = new ArrayList<Relationship>();
		
		for(r : (e.eContainer as OrmModel).relationships){
			if (r.source.entity.name.equals(e.name)) {
				elementSourceRelations.add(r)
			}
			if (r.target.entity.name.equals(e.name) && !r.unidirectional){
				elementTargetRelations.add(r)
			}
		}
		
		// INHERITANCE IMPORTS
		
		if (e instanceof Entity && (e.extends === null || !(e.extends instanceof Entity))) {
			addFromImport(importFroms, "base", "Base");
		}
		
		if (e instanceof MappedClass) {
			addFromImport(importFroms, "sqlalchemy.orm", "declarative_mixin")
		}
		
		if (e instanceof Entity && e.extends !== null) {
			if(e.extends instanceof Entity){
				addFromImport(importFroms, "entity", e.extends.name);
			} else {
				addFromImport(importFroms, "entity." + CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, e.extends.name), e.extends.name);
			}
			val strategy = (e as Entity).inheritanceStrategy
			if  (strategy === InheritanceStrategy.SINGLE_TABLE) {
				addFromImport(importFroms, "sqlalchemy.orm", "mapped_column");
				addFromImport(importFroms, "sqlalchemy", "String");
			}
		}
		
		// GENERAL ATTRIBUTE IMPORTS
		
		if (!e.attributes.filter(DataAttribute).empty) {
			addFromImport(importFroms, "sqlalchemy.orm", "Mapped");
			addFromImport(importFroms, "sqlalchemy.orm", "mapped_column");
		}
		
		if (!elementSourceRelations.empty) {
			if(!elementSourceRelations.filter[type != RelationshipType.MANY_TO_MANY].empty) {
				addFromImport(importFroms, "sqlalchemy", "ForeignKey");	
				addFromImport(importFroms, "sqlalchemy.orm", "mapped_column");
				imports.add("import uuid");
				addFromImport(importFroms, "sqlalchemy.dialects.postgresql", "UUID");
			}
			addFromImport(importFroms, "sqlalchemy.orm", "relationship");
			addFromImport(importFroms, "sqlalchemy.orm", "Mapped");
		}
		
		if (!elementTargetRelations.empty) {
			addFromImport(importFroms, "sqlalchemy.orm", "relationship");
			addFromImport(importFroms, "sqlalchemy.orm", "Mapped");
		}
		
		// ATTRIBUTE TYPE IMPORTS
		
		if (!e.attributes.filter(DataAttribute).filter[datatype == DataType.UUID].empty) {
			imports.add("import uuid");
			addFromImport(importFroms, "sqlalchemy.dialects.postgresql", "UUID");
		}
		
		if (!e.attributes.filter(DataAttribute).filter[datatype == DataType.INT].empty) {
			addFromImport(importFroms, "sqlalchemy", "Integer");
		}
		
		if (!e.attributes.filter(DataAttribute).filter[datatype == DataType.STRING].empty) {
			addFromImport(importFroms, "sqlalchemy", "String");
		}
		
		
		// Parse importFroms at end of import generation
		
		for (Map.Entry<String, TreeSet<String>> entry : importFroms.entrySet) {
			finalFromImports.add("from " + entry.key +  " import " + String.join(", ", entry.value))
		}
		
		return Stream.concat(imports.toList.stream, finalFromImports.toList.stream).collect(Collectors.toList);
	}
	
	private def addFromImport(HashMap<String, TreeSet<String>> importMap, String fromValue, String importValue) {
			val params = importMap.getOrDefault(fromValue, new TreeSet<String>())
			params.add(importValue)
			importMap.put(fromValue, params)
	}
}
