/*
 * generated by Xtext 2.28.0
 */
package org.big.orm.validation;

import java.util.regex.Pattern;

import org.big.orm.ormModel.Attribute;
import org.big.orm.ormModel.AttributeType;
import org.big.orm.ormModel.DataAttribute;
import org.big.orm.ormModel.Embeddable;
import org.big.orm.ormModel.EnumAttribute;
import org.big.orm.ormModel.EnumValue;
import org.big.orm.ormModel.InheritableElement;
import org.big.orm.ormModel.ModelElement;
import org.big.orm.ormModel.OrmModel;
import org.big.orm.ormModel.OrmModelPackage;
import org.big.orm.ormModel.Relationship;
import org.big.orm.ormModel.RelationshipType;
import org.eclipse.xtext.validation.Check;

/**
 * This class contains custom validation rules.
 *
 * See
 * https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class OrmModelValidator extends AbstractOrmModelValidator {
	
    private static final Pattern UPPER_CAMEL = Pattern.compile("^(?:[A-Z][a-z]+)+$");
    private static final Pattern LOWER_CAMEL = Pattern.compile("^[a-z]+(?:[A-Z][a-z]+)*$");
    private static final Pattern UPPER_SNAKE = Pattern.compile("^[A-Z]+(?:[_][A-Z]+)*$");
    private static final Pattern LOWER_SNAKE = Pattern.compile("^[a-z]+(?:[_][a-z]+)*$");
	
	
	@Check
	public void checkModelNameMatchesUpperCamel(OrmModel model) {
		if (!LOWER_SNAKE.matcher(model.getName()).matches()) {
			warning("Model name must always be in lower snake case", OrmModelPackage.Literals.ORM_MODEL__NAME, "invalidModel");
		}
	}
    
	@Check
	public void checkModelElementNameMatchesUpperCamel(ModelElement element) {
		if (!UPPER_CAMEL.matcher(element.getName()).matches()) {
			warning("Model element names must always be in upper camel case", OrmModelPackage.Literals.MODEL_ELEMENT__NAME, "invalidModelElement");
		}
	}
	
	@Check
	public void checkAttributeNameMatchesLowerCamel(Attribute attribute) {
		if (!LOWER_CAMEL.matcher(attribute.getName()).matches()) {
			warning("Attribute names must always be in lower camel case", OrmModelPackage.Literals.ATTRIBUTE__NAME, "invalidModelElement");
		}
	}
	
	@Check
	public void checkEnumValueMatchesLowerCamel(EnumValue value) {
		if (!UPPER_SNAKE.matcher(value.getValue()).matches()) {
			warning("Attribute names must always be in upper snake case", OrmModelPackage.Literals.ATTRIBUTE__NAME, "invalidModelElement");
		}
	}

	@Check
	public void checkRelationshipAttributeNames(Relationship relationship) {
		if (relationship.getSource().getAttributeName() == null) {
			warning("Relationship source always needs a name", OrmModelPackage.Literals.RELATIONSHIP__NAME, "invalidRelationship");
		}
		if (!relationship.isUnidirectional() && relationship.getTarget().getAttributeName() == null) {
			warning("Bidirectional relationships need a target name", OrmModelPackage.Literals.RELATIONSHIP__NAME, "invalidRelationship");
		}
		if (relationship.isUnidirectional() && relationship.getTarget().getAttributeName() != null) {
			warning("Unidirectional relationships can't have a target name", OrmModelPackage.Literals.RELATIONSHIP__NAME, "invalidRelationship");
		}
	}
	
	@Check
	public void checkRelationshipNameIsUpperCamelCase(Relationship relationship) {
		if (!UPPER_CAMEL.matcher(relationship.getName()).matches()) {
			warning("Relationship names must be in upper camel case", OrmModelPackage.Literals.RELATIONSHIP__NAME, "invalidRelationship");
		}
	}
	
	@Check
	public void checkRelationshipRequiredOnlyOnManyToOne(Relationship relationship) {
		if (relationship.isSourceRequired() && relationship.getType() != RelationshipType.MANY_TO_ONE) {
			warning("Required relationships only work for ManyToOne currently", OrmModelPackage.Literals.RELATIONSHIP__NAME, "invalidRelationship");
		}
	}
	
	@Check
	public void checkRelationshipAttributesOnlyOnManyToMany(Relationship relationship) {
		if (relationship.getType() != RelationshipType.MANY_TO_MANY && relationship.getAttributes().size() > 0) {
			warning("Additional attributes are only supported for MANY_TO_MANY relationships", OrmModelPackage.Literals.RELATIONSHIP__ATTRIBUTES, "invalidRelationship");
		}
	}
	
	
	@Check
	public void checkElementOnlyHasOneKey(InheritableElement element) {
		int keys = getKeyCount(element);
		if (keys != 1) {
			warning("Root entities must have exactly one primary key. For composite primary keys define an embeddable to be used as key.", OrmModelPackage.Literals.MODEL_ELEMENT__NAME, "invalidEntity");
		}
	}
	
	private int getKeyCount(InheritableElement element) {
		int keys = 0;
		keys = (int) (keys + element.getAttributes().stream().filter(a -> a.getType().equals(AttributeType.ID)).count());
		if (element.getExtends() != null) {
			keys = keys + getKeyCount(element.getExtends());
		}
		return keys;
	}
	
	@Check
	public void checkEmbeddableHasNoKey(Embeddable embeddable) {
		if (embeddable.getAttributes().stream().filter(a -> a.getType().equals(AttributeType.ID)).count() != 0) {
			warning("Embeddables are not allowed to have primary keys.", OrmModelPackage.Literals.MODEL_ELEMENT__NAME, "invalidEmbeddable");
		}
	}
	
	@Check
	public void checkRelationshipHasNoKey(Relationship relationship) {
		if (relationship.getAttributes().stream().filter(a -> a.getType().equals(AttributeType.ID)).count() != 0) {
			warning("Relationships are not allowed to have primary keys.", OrmModelPackage.Literals.RELATIONSHIP__NAME, "invalidRelationship");
		}
	}
	
	
	@Check
	public void checkRequiredOnlyOnDataAttribute(Attribute attribute) {
		if (!(attribute instanceof DataAttribute) && attribute.getType().equals(AttributeType.REQUIRED)) {
			warning("Required only allowed on data attributes.", OrmModelPackage.Literals.ATTRIBUTE__NAME, "invalidAttribute");
		}
	}
	
	@Check
	public void checkEmbeddableOnlyHasDataAttributes(Embeddable embeddable) {
		if (embeddable.getAttributes().stream().filter(a -> !(a instanceof DataAttribute)).count() > 0) {
			warning("Embeddables currently only support data attributes.", OrmModelPackage.Literals.MODEL_ELEMENT__NAME, "invalidEmbeddable");
		}
	}
	
	@Check
	public void checkEnumAttributeHasNoAttributeType(EnumAttribute enumAttribute) {
		if (!enumAttribute.getType().equals(AttributeType.NONE)) {
			warning("Enum Attributes don't support attribute types.", OrmModelPackage.Literals.ATTRIBUTE__NAME, "invalidEnumAttribute");
		}
	}

}
